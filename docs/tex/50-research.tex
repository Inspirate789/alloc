\chapter{Исследовательский раздел}



\section{Цель исследования}

Реализованный метод распределения памяти может иметь в различные сценарии использования и каждом из них оказывать различное влияние на характеристики выполнения программ. Предполагается, что изменение характеристик выполнения программы при применении реализованного метода зависит от класса алгоритма, который она реализует (см. п. \ref{alg_classes}).

Целью исследования является проведение сравнительного анализа разработанного метода с реализацией, существующей программирования Golang.

\section{Описание исследования}

Для проведения сравнительного анализа необходимо установить зависимость между длиной входа алгоритма и временем его выполнения для различных классов алгоритмов и для двух методов распределения памяти: встроенного и реализованного. Для этого были подготовлены тесты производительности для следующих алгоритмов:

\begin{enumerate}[label*=\arabic*)]
	\item алгоритм конвейерной обработки данных (класс VC);
	\item алгоритм сортировки слиянием (класс VL);
	\item алгоритм нахождения расстояния Левенштейна (класс VQ);
	\item алгоритм умножения матриц по Винограду (класс VP);
	\item алгоритм сортировки подсчётом (класс VE).
\end{enumerate}

Для каждого алгоритма были разработаны две реализации: одна использует встроенные средства языка Golang, а другая --- реализованный метод.



\section{Технические характеристики оборудования}

Ниже приведены технические характеристики устройства, на котором выполнялось тестирование.

\begin{itemize}[label*=---]
	\item Операционная система: Debian Linux 12 (bookworm) x86\_64, версия ядра 6.1.0-17.
	\item Объём оперативной памяти: 16 Гб.
	\item Процессор: Intel i5-9300H 2.4 ГГц.
\end{itemize}

Тестирование проводилось на ноутбуке, включенном в сеть электропитания. Во время тестирования ноутбук был нагружен только встроенными приложениями окружения, а также непосредственно системой тестирования.



\section{Результаты исследования}

\subsection{Алгоритм конвейерной обработки данных}

Для проведения замеров был разработан конвейер, состоящий из трёх линий: аллокация буфера фиксированного размера, запись данных в него и их чтение. В таблице \ref{tab:pipeline} представлены результаты замеров времени выполнения алгоритма при различном количестве заявок. 

\begin{table}[H]
	\centering
	\caption{Замеры времени выполнения алгоритма}\label{tab:pipeline}
	\renewcommand{\arraystretch}{1.2}
	\begin{tabular}{|I|J|J|}
		\hline
		\textit{Число заявок} & \textit{Время выполнения при использовании встроенных средств языка, мс} & \textit{Время выполнения при использовании реализованного метода, мс} \\ \hline
		10 & 271 & 321 \\ \hline
		50 & 476 & 458 \\ \hline
		100 & 702 & 678 \\ \hline
		500 & 1811 & 1720 \\ \hline
		1000 & 3389 & 3248 \\ \hline
		5000 & 19897 & 15272 \\ \hline
		10000 & 37349 & 27465 \\ \hline
	\end{tabular}
\end{table}

На рисунке \ref{fig:time-pipeline} представлены данные из таблицы \ref{tab:pipeline} в виде графика.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			xlabel=Длина входа алгоритма (шт),
			ylabel=Время выполнения алгоритма (мс),
			axis lines=left,
			xmin=0, xmax=10000,
			ymin=0, ymax=37350,
			grid = both,
			grid style = {dashed, lightgray!35},
			xtick distance = 1000,
			ytick distance = 5000,
			width = 0.98\textwidth,
			tick label style={font=\scriptsize},
			scaled ticks=false,
			height=0.3\textheight,
			legend entries={Реализованный метод, Встроенные средства языка},
			legend pos=north west]
			]
			
			\addplot [
			color=blue,
			mark=square,
			] coordinates {
				(10, 271)
				(50, 476)
				(100, 702)
				(500, 1811)
				(1000, 3388)
				(5000, 19897)
				(10000, 37349)
			};
			
			\addplot [
			color=red,
			mark=square,
			] coordinates {
				(10, 321)
				(50, 458)
				(100, 678)
				(500, 1720)
				(1000, 3248)
				(5000, 15272)
				(10000, 27465)
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени выполнения алгоритма от длины входа}
	\label{fig:time-pipeline}
\end{figure}

\subsection{Алгоритм сортировки слиянием}

В таблице \ref{tab:mergesort} представлены результаты замеров времени выполнения алгоритма сортировки слиянием при различных размерах входного массива целых чисел. 

\begin{table}[H]
	\centering
	\caption{Замеры времени выполнения алгоритма}\label{tab:mergesort}
	\renewcommand{\arraystretch}{1.2}
	\begin{tabular}{|I|J|J|}
		\hline
		\textit{Число элементов в массиве} & \textit{Время выполнения при использовании встроенных средств языка, мс} & \textit{Время выполнения при использовании реализованного метода, мс} \\ \hline
		100 & 91 & 13 \\ \hline
		500 & 694 & 111 \\ \hline
		1000 & 993 & 241 \\ \hline
		5000 & 5138 & 1566 \\ \hline
		10000 & 10037 & 3855 \\ \hline
		50000 & 51519 & 16459 \\ \hline
		100000 & 101879 & 42221 \\ \hline
	\end{tabular}
\end{table}

На рисунке \ref{fig:time-mergesort} представлены данные из таблицы \ref{tab:mergesort} в виде графика.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			xlabel=Длина входа алгоритма (шт),
			ylabel=Время выполнения алгоритма (мс),
			axis lines=left,
			xmin=0, xmax=100000,
			ymin=10, ymax=102000,
			grid = both,
			grid style = {dashed, lightgray!35},
			xtick distance = 10000,
			ytick distance = 20000,
			width = 0.98\textwidth,
			tick label style={font=\scriptsize},
			scaled ticks=false,
			height=0.3\textheight,
			legend entries={Реализованный метод, Встроенные средства языка},
			legend pos=north west]
			]
			
			\addplot [
			color=blue,
			mark=square,
			] coordinates {
				(100, 91)
				(500, 694)
				(1000, 993)
				(5000, 5138)
				(10000, 10037)
				(50000, 51519)
				(100000, 101879)
			};
			
			\addplot [
			color=red,
			mark=square,
			] coordinates {
				(100, 13)
				(500, 111)
				(1000, 241)
				(5000, 1566)
				(10000, 3855)
				(50000, 16459)
				(100000, 42221)
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени выполнения алгоритма от длины входа}
	\label{fig:time-mergesort}
\end{figure}

\subsection{Алгоритм нахождения расстояния Левенштейна}

В таблице \ref{tab:levenstein} представлены результаты замеров времени выполнения нерекурсивного алгоритма нахождения расстояния Левенштейна между строками равной длины.

\begin{table}[H]
	\centering
	\caption{Замеры времени выполнения алгоритма}\label{tab:levenstein}
	\renewcommand{\arraystretch}{1.2}
	\begin{tabular}{|I|J|J|}
		\hline
		\textit{Число символов в строках} & \textit{Время выполнения при использовании встроенных средств языка, мс} & \textit{Время выполнения при использовании реализованного метода, мс} \\ \hline
		100 & 184 & 42 \\ \hline
		300 & 1780 & 326 \\ \hline
		500 & 5258 & 5730 \\ \hline
		750 & 11621 & 1818 \\ \hline
		1000 & 19222 & 3483 \\ \hline
		3000 & 166382 & 31616 \\ \hline
		5000 & 544065 & 86802 \\ \hline
	\end{tabular}
\end{table}

На рисунке \ref{fig:time-levenstein} представлены данные из таблицы \ref{tab:levenstein} в виде графика.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			xlabel=Длина входа алгоритма (шт),
			ylabel=Время выполнения алгоритма (мс),
			axis lines=left,
			xmin=100, xmax=5000,
			ymin=0, ymax=550000,
			grid = both,
			grid style = {dashed, lightgray!35},
			xtick distance = 500,
			ytick distance = 50000,
			width = 0.98\textwidth,
			tick label style={font=\scriptsize},
			scaled ticks=false,
			height=0.3\textheight,
			legend entries={Реализованный метод, Встроенные средства языка},
			legend pos=north west]
			]
			
			\addplot [
			color=blue,
			mark=square,
			] coordinates {
				(100, 184)
				(300, 1780)
				(500, 5258)
				(750, 11621)
				(1000, 19222)
				(3000, 166382)
				(5000, 544065)
			};
			
			\addplot [
			color=red,
			mark=square,
			] coordinates {
				(100, 42)
				(300, 326)
				(500, 5730)
				(750, 1818)
				(1000, 3483)
				(3000, 31616)
				(5000, 86802)
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени выполнения алгоритма от длины входа}
	\label{fig:time-levenstein}
\end{figure}

\subsection{Алгоритм умножения матриц по Винограду}

В таблице \ref{tab:winograd} представлены результаты замеров времени выполнения алгоритма Винограда умножения квадратных матриц равной размерности.

\begin{table}[H]
	\centering
	\caption{Замеры времени выполнения алгоритма}\label{tab:winograd}
	\renewcommand{\arraystretch}{1.2}
	\begin{tabular}{|I|J|J|}
		\hline
		\textit{Размерность матриц} & \textit{Время выполнения при использовании встроенных средств языка, мс} & \textit{Время выполнения при использовании реализованного метода, мс} \\ \hline
		10 & 8 & 8 \\ \hline
		50 & 222 & 303 \\ \hline
		100 & 1495 & 2196 \\ \hline
		300 & 52627 & 78902 \\ \hline
		500 & 227228 & 406249 \\ \hline
		750 & 838280 & 1401997 \\ \hline
		1000 & 3049303 & 7017908 \\ \hline
	\end{tabular}
\end{table}

На рисунке \ref{fig:time-winograd} представлены данные из таблицы \ref{tab:winograd} в виде графика.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			xlabel=Длина входа алгоритма (шт),
			ylabel=Время выполнения алгоритма (мс),
			axis lines=left,
			xmin=0, xmax=1000,
			ymin=0, ymax=7020000,
			grid = both,
			grid style = {dashed, lightgray!35},
			xtick distance = 100,
			ytick distance = 1000000,
			width = 0.98\textwidth,
			tick label style={font=\scriptsize},
			scaled ticks=false,
			height=0.3\textheight,
			legend entries={Реализованный метод, Встроенные средства языка},
			legend pos=north west]
			]
			
			\addplot [
			color=blue,
			mark=square,
			] coordinates {
				(10, 7.742)
				(50, 222)
				(100, 1495)
				(300, 52627)
				(500, 227228)
				(750, 838280)
				(1000, 3049303)
			};
			
			\addplot [
			color=red,
			mark=square,
			] coordinates {
				(10, 7.765)
				(50, 303)
				(100, 2196)
				(300, 78902)
				(500, 406249)
				(750, 1401997)
				(1000, 7017908)
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени выполнения алгоритма от длины входа}
	\label{fig:time-winograd}
\end{figure}

\subsection{Алгоритм сортировки подсчётом}

В таблице \ref{tab:countingsort} представлены результаты замеров времени выполнения алгоритма сортировки подсчётом при различных размерах входного массива целых чисел, находящихся в полуинтервале $[0;10^7)$. 

\begin{table}[H]
	\centering
	\caption{Замеры времени выполнения алгоритма}\label{tab:countingsort}
	\renewcommand{\arraystretch}{1.2}
	\begin{tabular}{|I|J|J|}
		\hline
		\textit{Число элементов в массиве} & \textit{Время выполнения при использовании встроенных средств языка, мс} & \textit{Время выполнения при использовании реализованного метода, мс} \\ \hline
		1000 & 14687 & 18527 \\ \hline
		10000 & 15220 & 18667 \\ \hline
		100000 & 16556 & 20360 \\ \hline
		500000 & 20712 & 23525 \\ \hline
		1000000 & 28030 & 32345 \\ \hline
		5000000 & 79864 & 78069 \\ \hline
		10000000 & 138367 & 137969 \\ \hline
	\end{tabular}
\end{table}

На рисунке \ref{fig:time-countingsort} представлены данные из таблицы \ref{tab:countingsort} в виде графика.

\begin{figure}[H]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			xlabel=Длина входа алгоритма (шт),
			ylabel=Время выполнения алгоритма (мс),
			axis lines=left,
			xmin=0, xmax=10000000,
			ymin=10000, ymax=140000,
			grid = both,
			grid style = {dashed, lightgray!35},
			xtick distance = 1000000,
			ytick distance = 20000,
			width = 0.98\textwidth,
			tick label style={font=\scriptsize},
			scaled ticks=false,
			height=0.3\textheight,
			legend entries={Реализованный метод, Встроенные средства языка},
			legend pos=north west]
			]
			
			\addplot [
			color=blue,
			mark=square,
			] coordinates {
				(1000, 14687)
				(10000, 15220)
				(100000, 16556)
				(500000, 20712)
				(1000000, 28030)
				(5000000, 79864)
				(10000000, 138367)
			};
			
			\addplot [
			color=red,
			mark=square,
			] coordinates {
				(1000, 18527)
				(10000, 18667)
				(100000, 20360)
				(500000, 23525)
				(1000000, 32345)
				(5000000, 78069)
				(10000000, 137969)
			};
		\end{axis}
	\end{tikzpicture}
	\caption{График зависимости времени выполнения алгоритма от длины входа}
	\label{fig:time-countingsort}
\end{figure}



\section*{Выводы из исследовательского раздела}

В данном разделе было проведено исследование влияния разработанного метода распределения памяти на время выполнения программ, реализующих различные классы алгоритмов. Сравнительный анализ показал, что для классов алгоритмов VP и VE разработанный метод оказался эффективнее реализации, существующей в языке программирования Golang. Использование разработанного метода позволило снизить время выполнения алгоритма Винограда умножения матриц (класс VP) на 0.3-56.5\% в зависимости от размерности матриц, а время выполнения алгоритма сортировки подсчётом (класс VE) на 12-20.7\% в зависимости от размера входного массива при условии, что он не достигает 5000000.

