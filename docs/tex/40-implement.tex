\chapter{Классификация существующих решений}

\section{Критерии сравнения алгоритмов распределения памяти}

Анализ алгоритмов распределения памяти является задачей классификации. Ниже приведены критерии для их сравнения.

\begin{enumerate}[label*=\arabic*.]
	\item \textbf{Разделение объектов на поколения}. \newline
	Для оптимизации сборки мусора и уменьшения времени пауз в языках программирования может использоваться алгоритм поколений (см. п. \ref{generational}). В таблице сравнения будут использоваться обозначения <<+>> и <<->> для определения использования алгоритма поколений менеджером памяти рассматриваемого языка программирования.
	
	\item \textbf{Отсутствие хранения вспомогательных данных в объектах}. \newline
	Для реализации алгоритмов распределения памяти может понадобиться хранение дополнительных данных в выделяемых объектах, что создаёт зависимость объёма памяти, необходимого сборщику мусора, от количества отслеживаемых объектов. В таблице сравнения для обозначения факта хранения вспомогательных данных в объектах будет использоваться <<->>, иначе --- <<+>>.
	
	\item \textbf{Использование конкурентной сборки мусора}. \newline
	Для снижения времени пауз на сборку мусора менеджеры памяти некоторых языков программирования могут выполнять её конкурентно с потоками основной программы. В таблице сравнения для обозначения факта использования конкурентной сборки мусора будет использоваться <<+>>, иначе --- <<->>.
	
	\item \textbf{Использование параллельной сборки мусора}. \newline
	Менеджеры памяти некоторых языков программирования могут выполнять сборку мусора параллельно в нескольких потоках приложения, задействуя больше вычислительных ресурсов процессора для её ускорения. В таблице сравнения для обозначения факта использования параллельной сборки мусора будет использоваться <<+>>, иначе --- <<->>.
	
	\item \textbf{Отсутствие остановки потоков основной программы на весь цикл сборки мусора}. \newline
	Некоторые алгоритмы сборки мусора оптимизированы таким образом, чтобы останавливать работу потоков основной программы только на некоторых этапах сбора для минимизации времени пауз. В таблице сравнения для обозначения этого факта будет использоваться <<+>>, иначе --- <<->>.
	
	\item \textbf{Количество остановок потоков основной программы за один цикл сборки мусора}.
\end{enumerate}

Описанные выше характеристики алгоритмов распределения памяти, как правило, декларируются в документациях к соответствующим языкам программирования.



%GC паузы... Например, может ли gc перейти определённый порог оверхеда
%
%Реализован ли алгоритм поколений в GC
%
%
%
%Из gc handbook:
%
%Safety
%
%Throughput
%
%Completeness and promptness
%
%Pause time
%
%Space overhead
%
%Optimizations for specific languages
%
%Scalability and portability



\section{Сравнительный анализ алгоритмов распределения памяти}

Результаты сравнения алгоритмов распределения памяти приведены в таблице \ref{tab:compare}.

\begin{table}[H]
	\centering
	\caption{Сравнение алгоритмов распределения памяти}
	\label{tab:compare}
	\begin{tabular}{|c|c|c|c|c|c|c|c|}
		\hline
		  \rotatebox[origin=l]{90}{\parbox[l]{8cm}{Язык программирования}} 
		& \rotatebox[origin=l]{90}{\parbox[l]{8cm}{Сборщик мусора}} 
		& \rotatebox[origin=l]{90}{\parbox[l]{8.8cm}{Разделение объектов на поколения}} 
		& \rotatebox[origin=l]{90}{\parbox[l]{8.8cm}{Отсутствие хранения вспомогательных данных в объектах}} 
		& \rotatebox[origin=l]{90}{\parbox[l]{8.2cm}{Использование конкурентной сборки мусора}} 
		& \rotatebox[origin=l]{90}{\parbox[l]{8.2cm}{Использование параллельной сборки мусора}} 
		& \rotatebox[origin=l]{90}{\parbox[l]{9.1cm}{Отсутствие остановки потоков основной программы на весь цикл сборки мусора}} 
		& \rotatebox[origin=l]{90}{\parbox[l]{9.1cm}{Количество остановок потоков основной программы за один цикл сборки мусора}} 
		\\ \hline
		Python & По умолчанию 			& + & - & + & - & + & 1 \\ \hline
		\multirow{4}{*}{Java} & Serial 	& + & + & + & - & - & 1 \\ \cline{2-8}
		 & Parallel 					& + & + & + & + & - & 1 \\ \cline{2-8}
		 & Garbage-First 				& + & + & + & + & + & 2 \\ \cline{2-8}
		 & ZGC 							& + & + & + & + & + & 1 \\ \hline
		JavaScript & По умолчанию 		& - & + & - & - & - & 1 \\ \hline
		C\# & По умолчанию 				& + & + & + & + & - & 1 \\ \hline
		Golang & По умолчанию 			& - & + & + & + & + & 2 \\ \hline
	\end{tabular}
\end{table}



\section{Вывод}

% По мере того, как менеджеры памяти языков программирования становятся еще лучше и, возможно, даже начинают настраиваться под специальные программы, превзойти их по производительности становится все труднее.

% С течением времени языки программирования интегрируются со средами выполнения, которые предоставляют им низкоуровневые средства для реализации алгоритмов автоматического управления памятью.

Среди рассмотренных интерпретируемых языков программирования наиболее оптимизированным для различных сценариев использования можно считать менеджер памяти языка Python за счёт применения алгоритма поколений и подсчёта ссылок.

Среди рассмотренных компилируемых языков программирования наиболее универсальным и масштабируемым можно считать менеджер памяти языка Java за счёт предоставления пользователю возможности выбора сборщика мусора для выполнения каждой программы, а также оптимизации времени пауз на сборку мусора.
